<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Team CAPTCHA</title>
    <link rel="icon" href="static/images/favicon.ico">
    <!-- google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,300,500,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Oswald:400,300,700' rel='stylesheet' type='text/css'>

    <link href='static/css/bootstrap.min.css' rel="stylesheet">
    <link href='static/css/magnific-popup.css' rel="stylesheet">
    <link href='static/css/owl.carousel.css' rel="stylesheet">
    <link href='static/css/owl.carousel.theme.min.css' rel="stylesheet">
    <link href='static/css/ionicons.css' rel="stylesheet">
    <link href='static/css/main.css' rel="stylesheet">
    <!-- Include syntax highlighter-->
    <script type="text/javascript" src="static/js/shCore.js"></script>
    <script type="text/javascript" src="static/js/shBrushJScript.js"></script>
    <!-- For c -->
    <script type="text/javascript" src="static/js/shBrushCpp.js"></script>
    <link href="static/css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="static/css/shThemeDefault.css" rel="stylesheet" type="text/css" />


  </head>
  <body>
    <!-- Site Header -->
      <div class="site-header-bg">
          <div class="container">
              <div class="row">
                  <div style="height:50px;">
                      <a href="index.html"><img src='static/images/logo.png' alt="logo" class="center"></a>
                  </div>
                  <div class="col-sm-3 col-sm-offset-3 text-right">

                  </div>
              </div>
          </div>
      </div>

      <!-- Header -->
          <section id="header" class="main-header lab-header inner-header">
              <div class="container">

                  <div class="row">
                      <nav class="navbar navbar-default">
                          <div class="navbar-header">
                              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#site-nav-bar" aria-expanded="false">
                                  <span class="sr-only">Toggle navigation</span>
                                  <span class="icon-bar"></span>
                                  <span class="icon-bar"></span>
                                  <span class="icon-bar"></span>
                              </button>
                          </div>

                          <div class="collapse navbar-collapse" id="site-nav-bar">
                              <ul class="nav navbar-nav">
                                  <li><a href="index.html">Home</a></li>
                                  <li><a href="about.html">About</a></li>
                                  <li><a href="contract.html">Contract</a></li>
                                  <li class="active"><a href="labs.html">Labs</a></li>
                                  <li><a href="milestone.html">Milestones</a></li>
                                  <li><a href="#">Tutorials</a></li>
                              </ul>
                          </div>
                      </nav>
                  </div>

                  <div class="intro row">
                      <div class="overlay"></div>
                      <div class="col-sm-12">
                          <h1>Labs</h1>
                      </div>
                  </div> <!-- /.intro.row -->
              </div> <!-- /.container -->
              <div class="nutral"></div>
          </section> <!-- /#header -->

      <!-- Labs -->
      <section class="shop">
          <div class="container page-bgc">
              <div class="row">
                  <div class="col-sm-12">
                      <div class="title-box">
                          <p>Check Out Our</p>
                          <h2 class="title mt0">Labs</h2>
                      </div>
                  </div>
              </div>
              <div class="row">
                  <div class="boxed">

                    <!-- Lab 01 -->
                      <div class="col-sm-6">
                          <div class="shop-box">
                            <img class="img-full img-responsive" src="static/images/Lab1RobotPic.jpg" alt="lab01pic">
                            <div class="shop-box-hover text-center">
                              <div class="c-table">
                                <div class="c-cell">
                                  <a data-toggle="modal" data-target="#lab1modal">
                                    <span class="ion-ios-search-strong"></span>
                                  </a>
                                </div>
                              </div>
                            </div>
                          </div>
                          <div class="shop-box-title">
                              <div class="row">
                                <div class="col-sm-6">
                                  <h4>Lab One</h4>
                                  <h4>Last update: <span class="thin">September 7, 2018</span></h4>
                                </div>
                              </div>
                          </div>
                      </div>

                      <!-- Lab 02 -->
                      <div class="col-sm-6">
                          <div class="shop-box">
                              <img class="img-full img-responsive" src="static/images/milestonelab2.jpg" alt="shop">
                              <div class="shop-box-hover text-center">
                                  <div class="c-table">
                                      <div class="c-cell">
                                          <a data-toggle="modal" data-target="#lab2modal">
                                            <span class="ion-ios-search-strong"></span>
                                          </a>
                                      </div>
                                  </div>
                              </div>
                          </div>
                          <div class="shop-box-title">
                              <div class="row">
                                <div class="col-sm-6">
                                  <h4>Lab Two</h4>
                                  <h4>Last update: <span class="thin">September 31, 2018</span></h4>
                                </div>
                              </div>
                          </div>
                      </div>

                      <!-- Lab 03 -->
                      <div class="col-sm-6">
                          <div class="shop-box">
                              <img class="img-full img-responsive" src="static/images/milestonelab3.jpg" alt="shop">
                              <div class="shop-box-hover text-center">
                                  <div class="c-table">
                                      <div class="c-cell">
                                        <a data-toggle="modal" data-target="#lab3modal">
                                            <span class="ion-ios-search-strong"></span>
                                        </a>
                                      </div>
                                  </div>
                              </div>
                          </div>
                          <div class="shop-box-title">
                              <div class="row">
                                  <div class="col-sm-6">
                                    <h4>Lab Three</h4>
                                    <h4>Last update: <span class="thin">October 21, 2018</span></h4>
                                  </div>
                              </div>
                          </div>
                      </div>

                      <!-- Lab 04 -->
                      <div class="col-sm-6">
                        <div class="shop-box">
                            <img class="img-full img-responsive" src="static/images/lab-4.jpg" alt="shop">
                            <div class="shop-box-hover text-center">
                                <div class="c-table">
                                    <div class="c-cell">
                                        <a data-toggle="modal" data-target="#lab4modal">
                                            <span class="ion-ios-search-strong"></span>
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="shop-box-title">
                            <div class="row">
                                <div class="col-sm-6">
                                  <h4>Lab Four</h4>
                                  <h4>Last update: <span class="thin">September 7, 2018</span></h4>
                                </div>
                            </div>
                        </div>
                      </div>

                  </div>
              </div>
        </div>
      </section>

<!-- Modal fpr lab01 -->
<div class="modal fade modal-fullscreen" id="lab1modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <!-- Lab Title -->
        <h2 class="modal-title" id="myModalLabel">Lab 1: Microcontroller</h2>
      </div>
      <div class="modal-body">
        <!-- Lab Body -->
        <div style="width:80%; padding-left: 15%">
            <h3>Objectives</h3>
            <ul>
              <li>Learn how to use the various functionalities of the Arduino Uno and the Arduino IDE, as well as the GitHub repository.</li>
              <li>Construct a simple functional Arduino program using multiple external components and the Arduino Uno.</li>
              <li>Assemble robot and have it perform a simple autonomous task.</li>
            </ul>

            <h3>Teams</h3>
              <ul>
                <li>Team 1:   Joseph Primmer and Vicente Caycedo</li>
                <li>Team 2:   Francis Rayos del Sol and Eldor Bekpulatov</li>
              </ul>
              <br/>

            <h3>Internal LED</h3>
              <p>After downloading and opening the Arduino IDE, we started with the Blink example, available in File > Examples > 01. Basics > Blink. We compiled the code and made the internal LED toggle on (HIGH) and off (LOW) every second.</p>
              <img src="lab01/images/internalLED.JPG" style="height:300px; width:400px;">
              <p>Internal LED shown here in the ON/HIGH state.</p>

            <h3>External LED</h3>
              <p>We connected the external LED to the Arduino by wiring it in series with a 1k ohm resistor, as seen in the image below.</p>
              <img src="lab01/images/externalLED_diagram.PNG" style="height:300px; width:400px;">
              <p>Afterwards, we adjusted the Blink template to make the external LED blink instead of the internal LED. See the code snippet below for more details.</p>
              <pre class="brush: cpp">
                void setup(){
                    pinMode(13, OUTPUT);
                }
                void loop(){
    	             digitalWrite(13, HIGH);
    	             delay(500);
    	             digitalWrite(13, LOW);
    	             delay(500);
                }</pre>
              <img src=" lab01/images/externalLED.gif" style="height:300px; width:500px;">
              <br/>


            <h3>Reading Value of Potentiometer</h3>
            <p>We connected the potentiometer to our Arduino as shown in the diagram below.</p>
            <img src="lab01/images/pot_serialOut_diag.PNG" style="height:300px; width:400px;">
            <p>Using the AnalogReadSerial example, available in File > Examples > 01. Basics > AnalogReadSerial, we initialized a serial connection in setup() and designated A0 to be an input pin.</p>
            <p>Afterwards, using the analongRead call, we read the sensor value and printed it to the screen.</p>
            <pre class="brush: cpp">
              void setup(){
                  Serial.begin(9600);
    	            pinMode(A0, INPUT);
              }
              void loop(){
    	           Int analogIn = analogRead(A0);
    	           Serial.println(analogIn);
              }</pre>
            <p>Once we compiled and uploaded the code, the output was what we expected.</p>
            <img src="lab01/images/potentiometer_readings.gif" style="height:300px; width:500px;">
            <br/>


            <h3>Mapping Potentiometer Value to LED</h3>
            <img src="lab01/images/pot_ledOut_diag.PNG" style="height:300px; width:400px;">
            <p>Once the potentiometer, LED, and Arduino were connected, our next goal was to control the LED brightness with the potentiometer readings.</p>
            <p>Using the AnalogInOutSerial example, available in File > Examples > 03. Analog > AnalogInOutSerial, we read in the potentiometer value, a number in the range from 0-1023. We then scaled the reading down to the range 0-255 for the analogWrite function, which was used to control the LED brightness.</p>
            <pre class="brush: cpp">
              void setup() {
                  Serial.begin(9600);
                  pinMode(11, OUTPUT);
                  pinMode(A0, INPUT);
              }

              // the loop function runs over and over again forever
              void loop() {
                  int analogIn = analogRead(A0);
                  int ledOutputValue = (analogIn/1023.0)*255;
                  analogWrite(11, ledOutputValue);
                  Serial.println(analogIn);
              }</pre>
            <p>Below is a GIF of the LED changing brightness in response to the potentiometer readings.</p>
            <img src="lab01/images/Potentiometer_LED_Control.gif" style="height:300px; width:500px;">
            <br/>


            <h3>Mapping Potentiometer Value to Servo</h3>
            <img src="lab01/images/pot_servo_diag.PNG" style="height:300px; width:400px;">
            <p>In this part of the lab, we connected the potentiometer to now control the servos on our robot. The Parallax Continuous Rotation Servos we used received values from a PWM signal in a range from 0 to 180. At 0, the servos would rotate at full speed in one direction. At 180, the servos would rotate at full speed in the opposite direction. And at 90, the servos would come to a full stop.</p>
            <p>Similarly to the LED, we would read the value at the input pin, in this case A0, from the potentiometer, scale that value, and write it onto the servo. Our code is displayed below:</p>
            <pre class="brush: cpp">
              #include &ltServo.h&gt
              Servo aServo;
              void setup() {
                Serial.begin(9600);
                aServo.attach(11);
                pinMode(A0, INPUT);
              }

              // the loop function runs over and over again forever
              void loop() {
                int analogIn = analogRead(A0);
                int servoOutputValue = (analogIn/1023.0)*180;
                aServo.write(servoOutputValue);
                Serial.println(analogIn);
              }</pre>
            <p>Once our code compiled, we captured a video of the servos’ response to the change in the potentiometer values:</p>
            <img src="lab01/images/potentiometer_and _servo.gif" style="height:300px; width:500px;">
            <br/>


            <h3>Robot Assembly</h3>
            <p>Assembling the robot ultimately came down to creativity with the available parts.</p>
            <p>We began by mounting the wheels to the servo by simply pushing them into place. Using screws we were then able to attach a plastic mount to the servo that we could use to attach the entire servo and wheel to the base. We then proceeded to velcro the power bank to the bottom of the base (hidden from view) and screw in the Arduino to the top of the base for easy-to-access wiring. Finally, we began wiring and made sure to properly manage the cables to ensure a clean, sleek design that can be easy to debug in the future.</p>
            <img src="lab01/images/robot_pic.JPG" style="height:300px; width:400px;">
            <br/>


            <h3>Driving Robot Autonomously</h3>
            <p>After assembly was complete, we made the robot dance autonomously in order to learn how the servos could be used to make the robot turn in different directions.</p>
            <pre class="brush: cpp">
              Servo rightWheel;
              Servo leftWheel;
              int input = A0;

              //setup servos
              void setup() {
                rightWheel.attach(11);
                leftWheel.attach(10);
                pinMode(11, OUTPUT);
                pinMode(10, OUTPUT);
              }

              //loop the dance function
              void loop() {
                dance();
              }

              //function that makes the robot dance
              void dance(){
                rightWheel.write(0);
                leftWheel.write(0);
                delay(1000);
                leftWheel.write(180);
                delay(1000);
                leftWheel.write(0);
                rightWheel.write(180);
                delay(1000);
                leftWheel.write(180);
                rightWheel.write(180);
                delay(1000);
              }
            </pre>
              <img src="lab01/images/robot_dance.gif" style="height:300px; width:500px;">
              <br/>


              <h3>Work Distribution</h3>
              <ul>
                <li>Joseph Primmer: Pictures, Videos, and Code Snippets</li>
                <li>Francis Rayos del Sol & Vicente Caycedo: Lab Write Up</li>
                <li>Eldor Bekpulatov: Formatting and Publishing Lab Report Online</li>
              </ul>
              <br/>

            </div>
          </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<!-- Modal for lab02 -->
<div class="modal fade modal-fullscreen" id="lab2modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <!-- Lab Title -->
        <h2 class="modal-title" id="myModalLabel">Lab 2: Analog Circuitry and FFTs</h2>
      </div>
      <div class="modal-body">
        <!-- Lab Body -->
        <div style="width:80%; padding-left: 15%">
          <h3>Objectives:</h3>
          <ul>
            <li>Add additional sensors to our robot. </li>
            <li>Learn about Open Music Labs FFT.</li>
            <li>Make a microphone analog circuit that will detect a 660Hz whistle blow signifying the beginning of our maze mapping.</li>
            <li>Make an analog circuit to capture inputs from an IR sensor to detect nearby robots emitting IR at 6.08kHz, and distinguish them from decoys emitting at 18kHz.</li>
          </ul>
          <br>

          <h3>Teams</h3>
          <p>Traditionally there are two teams working in parallel, an acoustic team working on the microphone and an optical team working on the IR sensor. Instead, we had one team (Eldor Bekpulatov, Joseph Primmer, and Vicente Caycedo) working on both acoustics and optics. </p>
          <br>

          <h3>Open Music Labs FFT library</h3>
          <p>First we hooked up the function generator to the arduino, then we used the example serial fft program from the library to figure out what frequencies correspond to what bins.</p>

          <h4>Whistle Detection</h4>
          <p>In order to detect the 660Hz signal we used an online <a href="http://sim.okawa-denshi.jp/en/OPtazyuBakeisan.htm">tool</a> to help us calculate the values for a multiple feedback Hi-Q bandpass filter.</p>
          <p>We used the following circuit with calculated component values as part of our microphone circuit.</p>
          <img src="lab02/images/op_amp_circ.png" alt="op_amp" style="height:300px; width:500px;">

          <p>On top of multiple feedback bandpass filter, we also added an envelope detector, which uses a diode to half-wave rectify the output from the filter. Then, we used a passive low pass filter to smooth-out the waveform into a DC value. This way, we were able to get a DC output proportional to the amplitude of the output signal of the filter circuit. We read our output signal on the arduino with an analogRead(). We know the 660Hz is playing once the DC value that is read crosses a certain threshold. Note: We will determine this threshold once we learn the specifics of what speakers we will be using at competition and how far we will hold these from the robot.</p>
          <br>

          <h4>Circuit Schematic:</h4>
          <img src="lab02/images/mic_circuit.png" alt="mic_circuit" style="height:300px; width:500px;">
          <br><br>
          <p>After designing the circuit we then breadboarded the circuit to make sure everything worked:</p>
          <img src="lab02/images/mic_breadboard.png" alt="mic_breadboard" style="height:300px; width:500px;">
          <br><br>
          <p>We then transferred everything over to a protoboard:</p>
          <img src="lab02/images/mic_protoboard.png" alt="mic_protoboard" style="height:300px; width:500px;">
          <p>Here is our circuuit in action next to the speakers:</p>
          <iframe src="https://drive.google.com/file/d/1ZR3ECvjgEv6aohfUy_1KQwy_kLW4glpc/preview" width="640" height="480"></iframe>
          <br>
          <p>Here is our circuuit in action 2 feet away from speakers:</p>
          <iframe src="https://drive.google.com/file/d/1eCcMmPSRWES9QRMbmboHjCHh_iJ2AX4_/preview" width="640" height="480"></iframe>
          <br><br>
          <p>From the frequency sweep one can see that the filter isn’t absolutely perfect (the frequency band with the max gain is 520-620Hz), but from the two videos before we can see that this filter should definitely be good enough and will filter out the majority of other noises.</p>
          <iframe src="https://drive.google.com/file/d/11_MW1ChI9G-P-6uyT8mhj4lugYfw-tJY/preview" width="640" height="480"></iframe>
          <br>

          <h3>Robot Detection</h3>
          <p>Once we assembled our IR circuit, we uploaded a modified version of the example fft serial example sketch. We added these lines of code to figure out which buckets have the largest values when the IR hat is close to the robot:</p>
          <pre class="brush: cpp">
            if(fft_log_out[i] > 60){
                Serial.print("bucket ");
                Serial.print(i);
                Serial.print(" ");
                Serial.println(fft_log_out[i]);
            }
          </pre>
          <p>This code will only serial print the buckets with values greater than 60.</p>
          <br>

          <p>From the video below we can see that the main culprit is bucket 42:</p>
          <iframe src="https://drive.google.com/file/d/1vyNJhmGwefYcyAyTC4f1Vl37ZXSriykG/preview" width="640" height="480"></iframe>
          <br>
          <p>Using this same method we found that the 18kHz decoy did not fall in this bucket and instead fell in the 81 bucket. This means our circuit will not pick up decoys if we are just looking in the 42 bucket.</p>
          <p>We then removed the for loop from the example and added these lines of code to indicate when a robot has been detected:</p>
          <pre>
            if(fft_log_out[42] > 50){
              Serial.println("ROBOT");
            }else{
              Serial.println("NO ROBOT");
            }
          </pre>
          <br>
          <p>Here's the code in use:</p>
          <iframe src="https://drive.google.com/file/d/1DEeR7DQwYWacjtv5NscRGUv9_L21b7i5/preview" width="640" height="480"></iframe>
          <br>
          <p>Here is the final code from our integrated system with that can detect both the 660Hz start signal and 6.08kHz IR signals from other robots:</p>
          <pre class="brush: cpp">
            #define LOG_OUT 1 // use the log output function
            #define FFT_N 256 // set to 256 point fft
            #include &ltFFT.h&gt // include the library
            const int micInputPin = A1;
            int micValue = 0;
            void setup() {
              Serial.begin(115200); // use the serial port
              TIMSK0 = 0; // turn off timer0 for lower jitter
              ADCSRA = 0xe5; // set the adc to free running mode
              ADMUX = 0x40; // use adc0
              DIDR0 = 0x01; // turn off the digital input for adc0
            }
            void loop() {
              while(1) { // reduces jitter
                cli();  // UDRE interrupt slows this way down on arduino1.0
                for (int i = 0 ; i < 512 ; i += 2) { // save 256 samples
                  while(!(ADCSRA & 0x10)); // wait for adc to be ready
                  ADCSRA = 0xf5; // restart adc
                  byte m = ADCL; // fetch adc data
                  byte j = ADCH;
                  int k = (j << 8) | m; // form into an int
                  k -= 0x0200; // form into a signed int
                  k <<= 6; // form into a 16b signed int
                  fft_input[i] = k; // put real data into even bins
                  fft_input[i+1] = 0; // set odd bins to 0
                }
                fft_window(); // window the data for better frequency response
                fft_reorder(); // reorder the data before doing the fft
                fft_run(); // process the data in the fft
                fft_mag_log(); // take the output of the fft
                sei();
                //Serial.println("start");
                  if(fft_log_out[42] > 50){
                    Serial.println("ROBOT");
                  }else{
                    Serial.println("NO ROBOT");
                  }
                  micValue = analogRead(micInputPin);
                  if(micValue > 550){
                    Serial.println("START");
                  }
              }
            }

          </pre>

        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<!-- Modal for lab03 -->
<div class="modal fade modal-fullscreen" id="lab3modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <!-- Lab Title -->
        <h2 class="modal-title" id="myModalLabel">Lab 3: System Integration and Radio Communication</h2>
      </div>
      <div class="modal-body">
        <!-- Lab Body -->
        <div style="width:80%; padding-left: 15%">
          <h3>Objectives:</h3>
          <ul>
            <li>Integrate the components you have worked on in labs and milestones 1 and 2.</li>
            <li>Make a robot that can start on a 660 Hz tone, have it navigate a small test maze autonomously, and have it send the maze information it discovers wirelessly to a base station. The base station, in turn, will display these updates on a screen for debugging.</li>
          </ul>

          <h3>Teams:</h3>
          <p>For this lab, we are supposed to split into two groups with one group working on the radio component and the other on integrating robot start signals, line following, wall detection and detection of other robots (while ignoring decoys). However, we already completed the second part as part of Milestone 2 so we will be working on this lab as one group of four.</p>

          <h3>Radio Communication</h3>
            <h5>Data Scheme</h5>
            <p>We needed to transmit information about the physical location of our robot and some other properties like walls, treasures detected by our sensors in the most efficient/appropriate format so that we can easily decompose the message at the base station. We decided to continuously send three bytes of information at each cell/intersection, two designated for x- and y- coordinates of the robot, and one to encode information about the robots surroundings. So, we came up with a data scheme to encode information about each cell the following way:</p>
            <img src="lab03/data-diag.png" height=300px width=500px alt="data-scheme">

            <h5>Radio Connectivity</h5>
            <p>To start, we wired-up the RF transmitters to our arduinos. In order to regulate voltage down to the 3.3V we used a LM317 general voltage regulator. We chose resistor values of 240 and 390 to use in our regulator circuit to give us a voltage around 3.4V.</p>
            <img src="lab03/regulator.png" alt="regulator" height=300px width=500px>
            <br>
            <br>
            <p>Radio Module on our Robot.</p>
            <img src="lab03/radioModule.JPG" alt="radioModule" height=300px width=500px>
            <br>
            <br>
            <p>We needed to set up two radio modules, one to transmit maze information from the robot and the other to receive the data at the base station. So, we did just that:</p>
            <img src="lab03/baseModule.png" alt="baseModule" height=300px width=500px>
            <br>
            <br>
            <p>To finish up the Radio Connectivity we used sample codes provided to develop two versions of code to be deployed on each Arduino.</p>
            <h6>Robot</h6>
            <p>Our robot code would allocate three bytes to communicate to the base station. These three bytes then would be passed as reference to our funtions to be modified at each intersection/cell based on our data scheme. Then the radio module would transmit these values over to our base station. To identify the coordinates of our robot, we implemented a counter for orientation, which is responsible for keeping count of turns and identifying orientation relative to the maze. The following is our robot code:</p>
            <pre style="overflow: scroll; max-height: 600px" class="brush: cpp">
              /**
              * TEAM CAPTCHA FALL 2018
              * Joseph Primmer   | Vicente Caycedo
              * Eldor Bekpulatov | Francis Rayos del Sol
              */

              #define LOG_OUT 1 // use the log output function
              #define FFT_N 256 // set to 256 point fft

              // Servo Library
              #include &ltServo.h&gt
              // FFT Library
              #include &ltFFT.h&gt
              // Radio Libraries
              #include &ltSPI.h&gt
              #include &ltnRF24L01.h&gt
              #include &ltRF24.h&gt

              #define rightSensorPin A0
              #define leftSensorPin A1
              #define micInputPin A3
              #define leftWall 4
              #define frontWall 3
              #define rightWall 2
              #define lineSensorThreshold 930
              #define FIRsampRate 20
              #define FIRwindowSize 60
              #define DetectionRate 100

              Servo rightWheel;
              Servo leftWheel;

              RF24 radio(9, 10); // CE, CSN
              long long address = 0x0000000068LL;

              byte maze[9][9];
              /* Robot starts in top left square of map, facing south */
              int posX = 0; // row
              int posY = 0; // col

              /* Robot's orientation
              *  0: North
              *  1: East
              *  2: South
              *  3: West
              */
              int orientation = 2;

              void setup() {
               Serial.begin(115200);
               setupMotors();
               setupWallSensors();
               setupRadio();
               resetMaze();
              }

              void loop() {
               stopMoving();
               while(!startSignalDetected()){}
               while(true) {
                 rightHandFollow();
               }
              }

              /**** SET UP ****/

              /* Sets up left and right motors for movement*/
              void setupMotors() {
               pinMode(leftSensorPin, INPUT);
               pinMode(rightSensorPin, INPUT);
               leftWheel.attach(5);
               rightWheel.attach(6);
               pinMode(10, OUTPUT);
               pinMode(11, OUTPUT);
              }

              void setupWallSensors() {
               pinMode(leftWall, INPUT);
               pinMode(frontWall, INPUT);
               pinMode(rightWall, INPUT);
              }

              void setupRadio() {
               radio.begin();
               radio.openWritingPipe(address);
               radio.setPALevel(RF24_PA_HIGH);
               radio.stopListening();
              }

              void resetMaze() {
               /*
                * INFORMATION ENCODING FOR MAZE MAPPING
                * 1 Byte, x, is used to map information for each square
                * x[7:4] = North, East, South, West Wall detected
                *  x[3]  = Explored
                * x[2:0] = Treasure encoding
                *      000 - undefined
                *      001 - red square
                *      010 - red triangle
                *      011 - red circle
                *      100 - undefined
                *      101 - blue square
                *      110 - blue triangle
                *      111 - blue circle
                */
               byte x;
               for(int i = 0; i < 9; i++){
                 for(int j = 0; j < 9; j++){
                   maze[i][j] = 0x00;
                 }
               }
              }

              /**** MAZE TRAVERSAL ****/

              /* Circles maze by keeping right hand on wall */
              void rightHandFollow(){
               while(!followLine()){} // Keep moving straight until intersection is reached
                 if(canTurnRight()){
                   Serial.println("turn right");
                   turnRight();
                   followLine();
                 } else if(canMoveStraight()){
                   Serial.println("straight");
                 } else if(canTurnLeft()){
                   Serial.println("turn left");
                   turnLeft();
                   followLine();
                 } else {
                   Serial.println("stop");
                   stopMoving(); // FIXME: do 180 deg turn
                 }
                 //updatePos();
               //}
              }

              /* Updates robot's position in maze */
              void updatePos(){
               switch (orientation) {
                 case 0:
                   posX--;
                   break;
                 case 1:
                   posY++;
                   break;
                 case 2:
                   posX++;
                   break;
                 case 3:
                   posY--;
                   break;
                 default:
                   break;
               }
              }

              /* Updates robot's orientation in maze
                param turn: 0 if turned left, 1 if turned right.
              */
              void updateOrientation(int turn){
               if(turn){ //Turned right
                 orientation = (orientation + 1) % 4;
               } else {
                 orientation--;
                 if (orientation == -1){
                   orientation = 3;
                 }
               }
              }

              /* Creates mapping of current square and sends info to base */
              void mapMaze(){
               byte squareInfo;
               //Setting explored
               squareInfo |= 0b00001000;
               //Setting walls (depends on orientation)
               switch (orientation) {
                     case 0:
                         if(!canTurnRight()){
                           squareInfo |= 0b01000000;
                         }
                         if(!canMoveStraight()){
                           squareInfo |= 0b10000000;
                         }
                         if(!canTurnLeft()){
                           squareInfo |= 0b00010000;
                         }
                         break;
                     case 1:
                         if(!canTurnRight()){
                           squareInfo |= 0b00100000;
                         }
                         if(!canMoveStraight()){
                           squareInfo |= 0b01000000;
                         }
                         if(!canTurnLeft()){
                           squareInfo |= 0b10000000;
                         }
                         break;
                     case 2:
                         if(!canTurnRight()){
                           squareInfo |= 0b00010000;
                         }
                         if(!canMoveStraight()){
                           squareInfo |= 0b00100000;
                         }
                         if(!canTurnLeft()){
                           squareInfo |= 0b01000000;
                         }
                         break;
                     case 3:
                         if(!canTurnRight()){
                           squareInfo |= 0b10000000;
                         }
                         if(!canMoveStraight()){
                           squareInfo |= 0b00010000;
                         }
                         if(!canTurnLeft()){
                           squareInfo |= 0b00100000;
                         }
                         break;
                     default:
                       break;
               }
               // Update neighbor squares if possible
               // TODO: Is it necessary?
               // TODO:

               // TODO: Fix treasure
               squareInfo = squareInfo & 0b11111000; //Resets last three bits
               squareInfo = squareInfo | 0b1; //Sets last bit to temporarily indicate red square.

               maze[posX][posY] = squareInfo;
               transmitMsg();
              }

              /**** GENERAL ****/

              /* Returns true if start whistle detected */
              int samples[FIRwindowSize];
              int sIndex = 0;
              int sRateCount = 0;
              boolean startSignalDetected(){
               if(sRateCount >= FIRsampRate){
                 samples[sIndex] = analogRead(micInputPin);
                 sRateCount = 0;
                 sIndex++;
               }else{
                 delay(1);
                 sRateCount++;
               }
               if(sIndex > FIRwindowSize){
                 sIndex = 0;
               }long sum = 0;
               for(int i = 0; i < FIRwindowSize; i++){
                 sum += samples[i];
               }
               int output = sum/FIRwindowSize;
               if(output > 589)return true;
               else return false;
              }

              /* Transmits info to base */
              void transmitMsg(){
               char msg[3];
               msg[0] = char(posX);
               msg[1] = char(posY);
               msg[2] = char(maze[posX][posY]);
               radio.write(msg, 3);
              }

              /**** MOVEMEMENT ****/

              /* Stops servo motors */
              void stopMoving(){
               rightWheel.write(90);
               leftWheel.write(90);
              }

              /* Turns right */
              void turnRight(){
               //updateOrientation(1);
               delay(100);
               leftWheel.write(130);
               rightWheel.write(90);
               delay(800);
               int rightLine = analogRead(rightSensorPin);
               while(rightLine > lineSensorThreshold){
                 rightLine = analogRead(rightSensorPin);
               }
              }

              /* Turns left */
              void turnLeft(){
               //updateOrientation(0);
               delay(100);
               leftWheel.write(90);
               rightWheel.write(40);
               delay(800);
               int leftLine = analogRead(leftSensorPin);
               while(leftLine > lineSensorThreshold){
                 leftLine = analogRead(leftSensorPin);
               }
              }

              /* Follows the line and returns true when intersection found and false otherwise*/
              boolean followLine(){
               int rightLine = analogRead(rightSensorPin);
               int leftLine = analogRead(leftSensorPin);
               if(rightLine < lineSensorThreshold && leftLine < lineSensorThreshold){
                 // TODO: possibly stop moving to give time to make decisions
                 // mapMaze();
                 return true; // Intersection encountered
               } else if(sampleRobotDetect()){
                 stopMoving(); //Stand still if a robot is seen
               }
               else if(leftLine < lineSensorThreshold) {
                 // Left sensor white
                 rightWheel.write(90); //nudge left
                 leftWheel.write(130);
               } else if(rightLine < lineSensorThreshold) {
                 // Right sensor white
                 rightWheel.write(40); //nudge right
                 leftWheel.write(90);
               } else {
                 // Both sensors black
                 leftWheel.write(130);
                 rightWheel.write(40);
               }
               return false;
              }

              /**** SENSORS ****/

              boolean canTurnRight() {
               return !digitalRead(rightWall);
              }

              boolean canMoveStraight() {
               return !digitalRead(frontWall);
              }

              boolean canTurnLeft() {
               return !digitalRead(leftWall);
              }

              /* Samples the robot detect method and stores in detectState every (detection rate) calls, returns detectionState
              * Need this workaround because otherwise constantly doing fft makes robot react too slow
              */
              int detectCount = 0;
              boolean detectState = false;
              boolean sampleRobotDetect(){
               if(detectCount > DetectionRate){
                 if(robotDetect()){
                   detectState = true;
                 }else{
                   detectState = false;
                 }
                 detectCount = 0;
               }
               detectCount++;
               return detectState;
              }

              /* Returns true if robot detected */
              boolean robotDetect(){
                ADMUX = 0x42;
                 int init_adcsra = ADCSRA;
                 ADCSRA = 0xe5;
                 cli();  // UDRE interrupt slows this way down on arduino1.0
                 for (int i = 0 ; i < 512 ; i += 2) { // save 256 samples
                   while(!(ADCSRA & 0x10)); // wait for adc to be ready
                   ADCSRA = 0xf5; // restart adc
                   byte m = ADCL; // fetch adc data
                   byte j = ADCH;
                   int k = (j << 8) | m; // form into an int
                   k -= 0x0200; // form into a signed int
                   k <<= 6; // form into a 16b signed int
                   fft_input[i] = k; // put real data into even bins
                   fft_input[i+1] = 0; // set odd bins to 0
                 }
                 fft_window(); // window the data for better frequency response
                 fft_reorder(); // reorder the data before doing the fft
                 fft_run(); // process the data in the fft
                 fft_mag_log(); // take the output of the
                 ADCSRA = init_adcsra;
                 sei();
                 if(fft_log_out[42] > 50){
                     return true;
                  } else {
                     return false;
                  }
              }
            </pre>

            <h6>Base</h6>
            <p>We created a loop where we would receive 3 bytes from the radio that contain the row and column the robot is in as well as the byte containing information about the robots curent square. From there, we had the base decode the data. When reading the byte, we detected which direction wall existed and continuously added that information onto a string which we would have the base print. At the same time, we used bit storage and manipulation to determine if there was a treasure detected as well as the shape and color of each treasure. Our base station code is as follows:</p>
            <pre style="overflow: scroll; max-height: 600px" class="brush: cpp">
              #include &ltSPI.h&gt
              #include &ltnRF24L01.h&gt
              #include &ltRF24.h&gt

              RF24 radio(9, 10); // CE, CSN
              long long address = 0x0000000068LL;

              void setup() {
                Serial.begin(9600);
                while (!Serial) {
                  ; // Wait for serial port to connect. Needed for native USB port only
                }
                setupRadio();
              }

              void loop() {
                if (radio.available()) {
                  char text[32] = "";
                  radio.read(&text, sizeof(text));
                  String guiMsg = "";
                  guiMsg += String(int(text[0]));
                  guiMsg += ","+String(int(text[1]));
                  byte mazeInfo = text[2];
                  if(wallNorth(mazeInfo)){
                    guiMsg+=",north=true";
                  } else {
                    guiMsg+=",north=false";
                  }
                  if(wallEast(mazeInfo)){
                    guiMsg+=",east=true";
                  } else {
                    guiMsg+=",east=false";
                  }
                  if(wallWest(mazeInfo)){
                    guiMsg+=",west=true";
                  } else {
                    guiMsg+=",west=false";
                  }
                  if(wallSouth(mazeInfo)){
                    guiMsg+=",south=true";
                  } else {
                    guiMsg+=",south=false";
                  }

                  if(tShape(mazeInfo)!="none"){
                    guiMsg+=",tshape=" +(tShape(mazeInfo));
                    guiMsg+=",tcolor=" +(tColor(mazeInfo));
                    Serial.println(guiMsg);
                  }
                }
              }

              /**** SET UP ****/

              void setupRadio(){
                radio.begin();
                radio.openReadingPipe(0, address);
                radio.setPALevel(RF24_PA_MIN);
                radio.startListening();
              }

              /**** GENERAL ****/

              boolean wallNorth(byte data){
                return((data >> 7) & 1 == 0b1);
              }
              boolean wallEast(byte data){
                return((data >> 6) & 1 == 0b1);
              }
              boolean wallSouth(byte data){
                return((data >> 5) & 1 == 0b1);
              }
              boolean wallWest(byte data){
                return((data >> 4) & 1 == 0b1);
              }
              boolean isRobot(byte data){
                return((data >> 3) & 1 == 0b1);
              }

              String tShape(byte data){
                boolean bit0 = ((data)&1);
                boolean bit1 = ((data>>1)&1);
                if(!bit1&&bit0){
                  return "square";
                }
                else if(bit1 && !bit0){
                  return "triangle";
                }
                else if(bit1&&bit0){
                  return "circle";
                }else{
                  return "none";
                }
              }

              String tColor(byte data){
                boolean bit0 = ((data)&1);
                boolean bit1 = ((data>>1)&1);
                boolean bit2 = ((data>>2)&1);
                if(!bit0 && !bit1 && !bit2){
                  return "none";
                }
                else if(bit2){
                  return "blue";
                }
                else{
                  return "red";
                }
              }
            </pre>

            <h4>GUI Testing</h4>
            <p>Once we had our Radio Modules successfully communication, we wanted to test out the communication and GUI by passing randomly generated data-schemes for mapping the walls. The following video shows that process:</p>
            <iframe src="https://drive.google.com/file/d/1uCuKo-n-m_5ucmaIHq12umWYRT5J8SDI/preview" width="640" height="480"></iframe>
            <br>

            <p>We previously achieved acknowledgement of sound detection, IR sensors, and avoiding decoys in Milestone 2. Therefore, we only had to implement our partially developed codes to work concurrently with our main robot code. Our general code is provided above. We mostly had to debug and develop our own GUI using Python library called PyGame for this part of the lab. Our GUI listened to values directly printed on serial output of Arduino. Our output on Arduino follows the format that the GUI provided in class uses. But rather than visualizing our incoming data using provided GUI, we chose to unit test it with our own GUI, though it can be tested on both.</p>

            <p>Heres our robot solving the Maze using everything we have developed thus far. </p>
            <iframe src="https://drive.google.com/file/d/1bL1xvW6WJWDgn73Q53_Q3TufN43wbb_q/preview" width="640" height="480"></iframe>
            <br>

        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal for lab04 -->
<div class="modal fade modal-fullscreen" id="lab4modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">

      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
        <!-- Lab Title -->
        <h2 class="modal-title" id="myModalLabel">Lab 4 - FPGA and Shape Detection</h2>
      </div>

      <div class="modal-body">
        <!-- Lab Body -->
        <div style="width:80%; padding-left: 15%">
        <h3>Objective:</h3>
        <p>
          Develop an FPGA module capable of detecting basic shapes from a camera input, and pass this information on to the Arduino. This device will be mounted on the robot to identify these shapes on the walls of the maze.
        </p>

        <h3>Teams:</h3>
        <ul>
          <li>Team Arduino: Joseph Primmer (jp2228), Eldor Bekplatov (eb654)</li>
          <li>Team FPGA: Vicente Caycedo (vac55), Francis Rayos del Sol (fmr32)</li>
        </ul>

        <h3>Setting-up Arduino</h3>
        <p>We were responsible for wiring the camera, setting up its registers with the Arduino, and reading treasure data from the FPGA.</p>
        <p>Before deploying any code to Arduino, we disabled the internal pull-up resistors that are a part of the Arduino’s I2C interface. This is because they pull the signals that set up our camera to 5V, while our camera requires 3.3V. </p>
        <br>
        <p>Then, we started wiring the Arduino as specified in the diagram below.</p>
        <img src="lab04/Lab3CameraWiringDiagram.png" style="height:300px; width:400px;">
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-danger" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>
    <!-- Footer -->
      <section id="footer-widget" class="footer-widget">
          <div class="container header-bg">
              <div class="row">
                  <div class="col-sm-3">
                      <h3>External Links</h3>
                      <ul>
                        <li><a href="https://cei-lab.github.io/ece3400-2018/">ECE 3400 Website</a></li>
                        <li><a href='https://github.com/eldorbekpulatov/ece3400'>Our GitHub Repo</a></li>
                      </ul>
                  </div>

              </div>
          </div>
      </section>
    <!-- Scripts -->
    <script src='static/js/jquery-1.12.3.min.js'></script>
    <script src='static/js/bootstrap.min.js'></script>
    <script src='static/js/jquery.magnific-popup.min.js'></script>
    <script src='static/js/owl.carousel.min.js'></script>
    <script src='static/js/script.js'></script>
    <script type="text/javascript">SyntaxHighlighter.all()</script>
  </body>
</html>
